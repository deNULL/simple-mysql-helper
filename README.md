# simple-mysql-helper

Мой маленький велосипед для того, чтобы не писать SQL-запросы в PHP вручную. Штука для тех ситуаций, когда использовать настоящий ORM немного лениво.

Прежде чем использовать хелпер, объявите глобальные переменные `DB_NAME`, `DB_HOST`, `DB_USER` и `DB_PASS` (лучше всего — в отдельном конфиге). Впрочем, имя БД бывает удобно передавать в конструктор без объявления константы:

config.php:
```php
define('DB_HOST', 'localhost'); // Если не объявить, будет значение 'localhost'
define('DB_USER', 'user');      // Если не объявить, будет значение 'root'
define('DB_PASS', 'password');  // Если не объявить, будет значение ''
```

yourfile.php:
```php
include "config.php"
include "simple-mysql-helper.php"

DB::connect('playground');

$messages = DB::select('messages', ['peer_id' => '123'], 100);
print_r($messages);
```

Все методы можно вызывать и как методы экземпляра класса, так и как статические методы. При вызове статически будет использоваться последний созданный экземпляр (он доступен в `DB::$instance`).

## DB::select($table, $where, $limit, $order, $total)

Делает запрос `SELECT` к БД.

Параметры:
* `$table`: имя таблицы, из которой сделать выборку. Единственный обязательный параметр.
* `$where`: условие, ограничивающее выборку. Может быть ассоциативным массивом, строкой или константой `false`:
* * Если `$where` — ассоциативный массив, каждая пара «ключ-значение» становится дополнительным условием. Ключи — имена полей, значения — их значения. Если в качестве значения передан массив, то будет использован оператор `IN` для проверки вхождения в этот массив значений (при этом результат будет ассоциативным массивом с индексом по этому полю). Условия объединяются оператором `AND`.
* * Если `$where` — строка, она непосредственно вставляется в запрос после ключевого слова `WHERE`. За экранирование отвечаете вы сами.
* * Если `$where === false`, то ограничений на выборку не накладывается.
* `$limit`: число возвращаемых результатов. Может быть массивом, строкой, положительным числом, константой `0` или `false`:
* * Если `$limit` — массив, то первый элемент в нём это смещение, а второй — число результатов.
* * Если `$limit` — строка, она непосредственно вставляется в запрос после ключевого слова `LIMIT`. За экранирование отвечаете вы сами.
* * Если `$limit` — положительное число, оно используется для задания числа возвращаемых результатов.
* * Если `$limit === 0`, то возвращается либо первый результат, либо `false`, если ничего не найдено.
* * Если `$limit === false`, то ограничений на число результатов нет.
* `$order`: порядок сортировки, строка. Если это непустая строка, то вставляется после ключевых слов `ORDER BY`.
* `$total`: если `true`, то будет сделан дополнительный запрос, возвращающий общее число подходящих под условия результатов. В этом случае метод вернёт массив из пары элементов — сами результаты и это число. Полезно для пагинации.

Возвращает массив, содержащий все подходящие строки в виде ассоциативных массивов. Если был передан `$limit === 0`, вернется единственный ассоциативный массив (если он нашелся), без оборачивания во внешний массив. Если среди условий была проверка на вхождение поля в массив значений, то результат будет проиндексирован по значениям этого поля.

## DB::assoc($table, $assoc, $where, $limit, $order, $total)

Делает запрос `SELECT` аналогично методу `DB::select`, но всегда возвращает ассоциативный массив, проиндексированный по полю (полям) `$assoc`.

Если в качестве `$assoc` передать массив строк, то результатом будет многомерный массив, каждый из уровней вложенности которого соответствует элементу массива `$assoc`.

## DB::single($table, $where, $order)

Короткая запись для `DB::select($table, $where, 0, $order)`. Выбирает единственную строку из таблицы, если она существует.

## DB::insert($table, $vals, $keys)

Вставка новой строки (или строк) с возможным обновлением существующих строк.

Параметры:
* `$table`: имя таблицы, в которую нужно вставить строки. 
* `$vals`: ассоциативный массив, описывающий единственную добавляемую строку, либо массив из ассоциативных массивов, если нужно добавить несколько строк.
* `$keys`: опциональный ассоциативный массив, описывающий, что следует делать с полями, если возник конфликт (запись уже существует). Ключи — имена полей, значениями могут быть следующие строковые константы:
* * `'UPD'`: при конфликте новое значение перезаписывает старое.
* * `'INC'`: при конфликте старое значение увеличивается на единицу.
* * `'ADD'`: при конфликте новое значение суммируется со старым.
* * `'MAX'`: при конфликте берётся максимум из нового и старого значений.
* * `'MIN'`: при конфликте берётся минимум из нового и старого значений.
* * любая другая непустая строка — подставляется после "`имя поля` = " (без экранирования).

Если в качестве `$keys` передать обычный (не ассоциативный) массив, то он будет использован как список полей в добавляемых строках. Если в одной из строк в массиве `$vals` соответствующее значение отсутствует, будет подставлено значение `NULL`.

При успешном выполнении метод возвращает идентификатор вставленной строки (значение первичного ключа).
